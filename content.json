{"meta":{"title":"Lee's Blog","subtitle":"Study Notes","description":"","author":"Lee","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-12-19T13:32:15.000Z","updated":"2021-12-19T13:39:47.195Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-12-19T13:40:38.000Z","updated":"2021-12-19T13:42:16.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Welcome to My Blog","slug":"hello-world","date":"2021-12-19T08:54:43.037Z","updated":"2021-12-19T14:40:41.424Z","comments":true,"path":"2021/12/19/hello-world/","link":"","permalink":"http://example.com/2021/12/19/hello-world/","excerpt":"Starting now! Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Starting now! Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"装饰器 decorator","slug":"装饰器 decorator","date":"2021-12-17T16:00:00.000Z","updated":"2021-12-19T15:08:33.001Z","comments":true,"path":"2021/12/18/装饰器 decorator/","link":"","permalink":"http://example.com/2021/12/18/%E8%A3%85%E9%A5%B0%E5%99%A8%20decorator/","excerpt":"","text":"装饰器 不改变函数代码，且保持函数调用方法不变，增加新的功能（或给类增加属性和方法） 核心思想：用一个函数（或者类）去装饰一个旧函数（或者类），造出一个新函数（或者新类） 语法规则：在原有的函数上加@符，装饰器会把下面的函数或方法当作参数传递到装饰器中 应用场景：引入日志，函数执行时间统计，执行函数前的准备工作，执行函数后的处理工作，权限校验，缓存等 123@outerdef func(): pass 1.装饰器原型与定义利用闭包，把函数当作参数传递，并且在函数内去调用传递进来的函数，并返回一个函数 12345678# 定义外函数，接收一个函数作为参数def outer(f): # 定义内函数，并且在内函数中调用了外函数的参数 def inner(): print(&quot;我是外函数中的内函数1&quot;) f() print(&quot;我是外函数中的内函数2&quot;) return inner 123456# 定义普通函数def old: print(&quot;我是普通函数&quot;)# old()直接调用 old = outer(old)# outer函数返回了inner函数old() # 此时再调用old等同于调用了inner函数 装饰器用法 12345# 改为装饰器用法@outerdef old(): print(&quot;我是一个普通函数&quot;)old() 2.统计函数执行时间12345678910111213141516inport time# 定义一个统计函数执行时间的装饰器def runtime(f): def inner(): start = time.pref_counter() f() end = time.perf_counter()-start print(f&#x27;函数执行时间为:&#123;end&#125;&#x27;) return inner@runtimedef func(): for i in range(10): print(i,end=&#x27;&#x27;) time.sleep(1)func() 3.装饰器的嵌套 普通装饰器 1234567891011def outer(f): def inner(): print(&quot;内函数1&quot;) f() print(&quot;内函数2&quot;) return inner@outerdef func(): print(&quot;普通函数&quot;)func() 再定义一个装饰器 12345678910111213141516171819202122# 装饰器1def outer(f): def inner(): print(&quot;内函数1&quot;) f() print(&quot;内函数2&quot;) return inner# 装饰器2def kuozhan(f): def kzinner(): print(&quot;扩展1&quot;) f() print(&quot;扩展2&quot;) return kzinner@kuozhan@outerdef func(): print(&quot;普通函数&quot;)func() 4.装饰带有参数的函数在inner函数中添加参数即可 1234567891011def outer(f): def inner(arg): print(&quot;内函数1&quot;) f(arg) print(&quot;内函数2&quot;) return inner@outerdef func(arg): print(f&quot;普通函数&#123;arg&#125;&quot;)func() 装饰带有多参数的函数也是一样的道理 5.带有参数的装饰器用于流程控制 给当前的装饰器套一个壳，用于接收装饰器的参数 12345678910111213141516171819def kuozhan(var) def outer(f): def inner1: print(&quot;inner1&quot;) f() def inner2(): print(&quot;inner2&quot;) f() if var == 1: return inner1 else: return inner2 return outer# 本来是outer的参数，用壳接收参数@kuozhan(1)def func(): print(&quot;普通函数&quot;)func() 6.类装饰器装饰函数12345678910111213141516class Outer(): # 魔术方法，当把该类的对象当函数调用时，自动触发 def __call__(self, f): self.f = f return self.inner # 在定义的需要返回的新方法中，进行装饰和处理 def inner(self, arg): print(&#x27;1&#x27;) self.f(arg) print(&#x27;2&#x27;) @Outer() # 实例化对象obj @obj ==&gt; obj(func) ==&gt; 执行__call__(func)方法 ==&gt; 返回inner()调用def func(arg): print(&quot;普通函数&quot;,arg)func(&#x27;a&#x27;) 7.用类方法装饰函数12345678910111213class Outer: def newinner(f): Outer.f = f # 把传递进来的函数定义为类方法 return Outer.inner # 返回一个新的类方法 def inner(): print(&#x27;1&#x27;) Outer.f() print(&#x27;2&#x27;) @Outer.newinner # Outer.newinner(func) ==&gt; Outer.innerdef func(): print(&#x27;1&#x27;)","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}],"categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]}