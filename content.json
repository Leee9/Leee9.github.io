{"meta":{"title":"Lee's Blog","subtitle":"Study Notes","description":"Time proves, delivers, alters and eradicates ad infinitum","author":"Lee","url":"http://leee9.cn","root":"/"},"pages":[{"title":"categories","date":"2021-12-19T13:32:15.000Z","updated":"2021-12-19T13:39:47.195Z","comments":true,"path":"categories/index.html","permalink":"http://leee9.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-12-19T13:40:38.000Z","updated":"2021-12-19T13:42:16.000Z","comments":true,"path":"tags/index.html","permalink":"http://leee9.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库系统概论 1.绪论","slug":"1.绪论","date":"2021-12-22T21:08:44.500Z","updated":"2021-12-22T21:18:42.766Z","comments":true,"path":"2021/12/23/1.绪论/","link":"","permalink":"http://leee9.cn/2021/12/23/1.%E7%BB%AA%E8%AE%BA/","excerpt":"第一章的概念非常多，很多概念都反复出现，需要捋清楚其中的逻辑关系，比如1.2.3中数据模型的基本组成的数据结构，数据操纵与完整性约束，在后面三个具体的数据模型中都分别具体地进行说明。第一章整个是对一些概念的入门和综述内容，比如关系模型在第二章关系数据库中也会给出更详细的介绍。","text":"第一章的概念非常多，很多概念都反复出现，需要捋清楚其中的逻辑关系，比如1.2.3中数据模型的基本组成的数据结构，数据操纵与完整性约束，在后面三个具体的数据模型中都分别具体地进行说明。第一章整个是对一些概念的入门和综述内容，比如关系模型在第二章关系数据库中也会给出更详细的介绍。 1.1 数据库系统概述1.1.1 数据库的4个基本概念 数据(Data) 数据与其语义是不可分的 数据库(Database) 数据库的定义 数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合 数据库的基本特征 数据按照一定的数据模型组织、描述和储存 可为各种用户共享、冗余度较小、易扩展 数据独立性较高 数据库管理系统(DBMS) DBMS是位于用户与操作系统之间的一层数据管理软件，是基础软件，也是一个大型复杂的软件系统，可以科学地组织和存储数据、高效地获取和维护数据 数据定义功能 DDL数据定义语言定义数据库中的数据对象 数据组织、存储和管理 分类组织、存储和管理各类数据 确定组织数据的文件结构和存取方式 实现数据之间的联系 提供多种存取方式提高存取效率 数据操纵功能 DML数据操纵语言实现对数据库的基本操作：查询、插入、删除和修改 数据库的事务管理和运行管理 数据库在建立、运行和维护时由数据库管理系统统一管理和控制，保证事务正常运行 保证数据的安全性、完整性、多用户并发使用 发生故障后系统恢复 数据库的建立和维护功能 数据库初始数据的装载和转换 数据库转储、恢复功能 数据库的重组织 性能监视、分析等 其他功能 数据库管理系统和网络中其他软件系统的通信 数据库管理系统之间的数据转换 异构数据库之间的互访和互操作 数据库系统(DBS) DBS是指在计算机系统种引入数据库后的系统构成，不引起混淆的情况下常常简称为数据库 数据库系统的构成 数据库 数据库管理系统（及其应用开发工具） 应用程序 数据库管理员(DBA) 1.1.2 数据库管理技术的产生和发展 数据管理：对数据进行分类、组织、编码、存储、检索和维护。数据管理时数据处理的中心问题 数据管理技术的发展过程 人工管理阶段 文件系统阶段 数据库系统阶段 数据的管理者 用户（程序员），数据不保存 文件系统，数据可长期保存 数据库管理系统 数据面向的对象 某一应用程序 某一应用 现实世界，企业等 数据的共享程度 无共享，冗余度极大 共享性差，冗余度大 共线性高，冗余度小 数据的独立性 不独立 独立性差 具有较高的物理独立性和一定的逻辑独立性 数据的结构化 无结构 记录内由结构，整体无结构 整体结构化，由数据模型描述 数据控制能力 应用程序自己控制 应用程序自己控制 由DBMS提供数据安全性、完整性、并发控制和恢复能力 1.1.3 数据库系统的特点 数据结构化 不仅数据内部结构化，整体也是结构化，数据之间有联系 数据记录可以变长 数据的最小存取单位是数据项 数据用数据模型描述，无需应用程序定义 数据的共享性高，冗余度低且易扩充 数据的独立性高 物理独立性：用户的应用程序与数据库中的数据的物理存储是相互独立的，当数据的物理存储改变了，应用程序不用变 逻辑独立性：用户的应用程序域数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变 数据独立性由DBMS的二级映像功能来保证 数据由数据库管理系统统一管理和控制 数据的安全性(Security)维护 数据的完整性(Integrity)检查 并发控制(Concurrency Control) 数据库回复(Recovery) 1.2 数据模型数据模型是对现实世界数据特征的抽象，即现实世界的模拟，数据模型是数据库系统的核心和基础 1.2.1 两类数据模型数据模型分为两个不同层次 概念模型，也称信息模型，按照用户的观点对数据和信息建模，用于数据库设计 逻辑模型和物理模型 逻辑模型主要包括：网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等。按照计算机系统的观点对数据建模，用于DBMS实现 物理模型是对数据最底层的抽象，描述数据在系统内（磁盘上）的表示方法和存取方法 1.2.2 概念模型 信息世界中的基本概念 实体(Entity)–客观存在并且可以互相区别的事物称为实体 属性(Attribute)–实体所具有的某一特征称为属性，一个实体可以用若干个属性来刻画 码(Key)–唯一标识实体的属性集称为码 实体型(Entity Type)–用实体名及其属性名集合来抽象和刻画同类实体称为实体型 实体集(Entity Set)–同一类型实体的集合称为实体集 联系(Relationship)–现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系 实体内部的联系：即组成实体的各个属性之间的联系 实体之间的联系：通常指不同实体集之间的联系，有一对一，一对多，多对多等多种类型 实体-联系方法(Entity-Relationship Approach)，E-R方法/E-R模型，用E-R图来描述现实世界的概念模型 1.2.3 数据模型的基本组成数据模型是严格定义了一组概念的集合，精确地描述了系统的静态特性-数据结构、动态特性-数据操作和完整性约束条件(Integrity Constraints) 数据结构 数据结构的类型来命名数据模型，比如层次结构-层次模型、网状结构-网状模型、关系结构-关系模型 描述数据库的组成对象–对象的类型、内容和性质以及对象之间的联系 数据操作 对数据库中各个对象的实例允许执行的操作的集合，包括操作以及有关的操作规则 数据操作的类型：查询、更新（增、删、改） 实现操作的语言 数据的完整性约束条件 一组完整性规则的集合 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则 用以限定符合数据模型的数据库状态以及状态的变化，以确保数据的正确、有效和相容 反映和规定必须遵守的基本的通用的完整性约束条件 下面具体的数据模型中会给出具体的完整性约束条件 1.2.4 常用的数据模型 层次模型(Hierarchical Model)–格式化模型 网状模型(Network Model)–格式化模型 结构化模型中数据结构的单位：基本层次联系 双亲结点–子女结点一对多（包括一对一）的联系 关系模型(Relational Model) 面向对象数据模型(Object Oriented Data Model)–对象模型 对象关系数据模型(Object Relational Data Model)–对象模型 半结构化数据模型(Semistructure Data Model) 其他还有非结构化数据模型、图模型等 1.2.5 层次模型定义：满足以下两个条件的基本层次联系 有且只有一个节点没有双亲结点，称为根结点 根以外的其他节点有且只有一个双亲结点 数据结构：层次模型用树形结构来表示各类实体以及实体之间的联系 实体型：用记录类型描述，每个结点表示一个记录类型（实体） 属性：用字段描述，每个记录可以包含若干个字段 联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系 特点 只能处理一对多（包括一对一）的实体联系 任何记录值只有按其路径查看 没有子女记录值能脱离双亲的记录值而存在 数据操纵和完整性约束 数据操纵，即查询、插入、删除、更新 完整性约束条件 没有相应的双亲结点就不能插入子女结点值 删除双亲结点值，相应的子结点点值同时被删除 更新操作时，要更新所有相应记录，以保证数据的一致性 优缺点 优点 数据结构清晰简单 查询效率高，性能优于关系模型，不低于网状模型 提供了良好的完整性支持 缺点 结点间多对多联系表示不方便 插入和删除操作限制多，应用程序编写比较复杂 查询子女结点必须通过双亲结点 命令（语言）趋于程序化，即描述性差 1.2.6 网状模型 允许一个以上的结点无双亲 一个结点可以有多于一个双亲 数据结构：网状数据库采用网状结构来表示各类实体以及实体间的联系，表示方法与层次数据模型相同，特点如下 允许两个结点之间有多种联系 要为每个联系命名，并指出与该联系有关的双亲记录和子女记录 多对多联系在网状模型中的表示 间接表示，将多对多联系分解成一对多联系 数据操纵与完整性约束 导航式的查询语言和增删改操作语言 允许插入尚未确定双亲结点值的子女结点值 允许只删除双亲结点值 完整性约束条件不严格 支持码 保证一个联系中双亲记录与子女记录之间是一对多联系 可以定义双亲记录和子女记录之间的某些约束条件 优缺点 优点 能够更为直接描述现实世界，如一个结点可以有多个双亲 具有良好的性能，存取效率较高 缺点 结构比较复杂，而且随着应用环境的扩大，数据库的结构越来越复杂，不利于最终用户掌握 DDL,DML语言复杂，用户不容易使用 记录直接是通过存取路径实现的，应用程序必须选择存取路径，加重了程序员的负担 1.2.7 关系模型在用户观点下，关系模型中数据的逻辑结构是一张二维表 关系模型的数据结构 关系(Relation)–每个关系对应一张表 元组(Tuple)–表的一行为一个元组 属性(Attribute)–表的一列为一个属性，起个名字为属性名 主码(Key)–能够唯一确定一个元组的属性组 域(Domain)–具有相同数据类型的值的集合。属性的取值范围来自某个域 分量–元组中的一个属性值 关系模式–对关系的描述 关系名(属性1, 属性2,…,属性n) 关系必须是规范化的，满足一定的规范条件，比如，不允许表中还有表，即每个属性都是原子不可分的（第一范式） 数据操纵和完整性 数据操作是集合操作，操作对象和操作结果都是关系 存取路径对用户隐蔽，用户不必说明怎么找，只需指出找什么，提高了数据的独立性，提高了用户生产率 完整性 实体完整性 参照完整性 用户定义的完整性 优缺点 优点 建立在严格的数学概念的基础上 概念单一 实体和各类联系都用关系来表示 对数据的检索结果也是关系 关系模型的存取路径对用户隐蔽 具有更好的数据独立性，更好的安全保密性 简化了程序员的工作和数据库开发建立的工作 缺点 查询效率往往不如格式化数据类型 为了提高性能必须对查询请求优化，增加了开发DBMS的难度 1.3 数据库系统的结构从数据库应用开发人员角度看 数据库系统采用三级模式结构，是数据库系统内部的系统结构 从数据库最终用户角度看 单用户结构、主从式结构、分布式结构、客户-服务器、浏览器-应用服务器/数据库服务器等 1.3.1 数据库系统模式的概念 模式(Schema) 是对数据库逻辑结构和特征的描述 是型的表述，不涉及具体值 模式是相对稳定的 实例(Instance) 数据库某一时刻的状态–模式的一个具体值 同一个模式可以有很多实例 实例随数据库中的数据更新而变动 1.3.2 数据库系统的三级模式结构 模式(Schema)–逻辑模式 数据库全体数据的逻辑结构和特征的描述，所有用户的公共数据视图 模式是数据库系统模式结构的中心，与物理存储细节与硬件环境都无关 外模式(External Schema)–子模式/用户模式 用户使用的局部数据的逻辑结构和特征的描述，数据视图，与某一应用有关的数据的逻辑表示 外模式通常是模式的子集，一个模式可以有多个外模式，反映不同用户的应用需求、看待数据的方式以及对数据保密的要求 模式中的某一数据在不同的外模式中，结构、类型、长度、保密级别都可以不同 内模式(Internal Schema)–存储模式 数据物理结构和存储方式的描述 数据在数据库内部的表示方式，如记录的存储方式（顺序、堆等），索引的组织方式（B+树， Bitmap，Hash）等等其他组织方式 一个数据库只有一个内模式 1.3.3 数据库的二级映像功能与数据独立性三级模式是对数据的三个级别抽象，DBMS内部提供二级映像：外模式/模式映像，模式/内模式映像，是三个抽象层次之间的联系和转换 外模式/模式映像 每个外模式都对应一个外模式/模式映像，通常包含在各个外模式的描述中 保证数据的逻辑独立性 当模式改变时，DBA对外模式/模式映像作相应改变，使外模式保存不变 应用程序根据外模式编写，应用程序不用修改，保证了数据与程序的逻辑独立性 模式/内模式映像 定义了数据全局逻辑结构和存储结构直接的对应关系 保证数据的物理独立性 当数据库的存储结构改变时（如选用另一种存储结构），DBA修改模式/内模式映像，使模式保持不变 模式不变，则应用程序不变，保证了数据和程序的物理独立性 二级映像功能和数据独立性 保证应用程序的稳定性 从程序为中心–发展为以数据为中心 数据的存取由DBMS管理 1.4 数据库系统的组成数据库、数据库管理系统（及其开发工具）、应用程序、数据库管理员 1. 硬件平台及数据库 数据库系统对硬件资源的要求 足够大的内存 足够大的磁盘或磁盘阵列等外部设备 较高的通道能力，提高数据传送率 2. 软件 数据库管理系统 支持DBMS运行的操作系统 与数据库接口的高级语言及其编译系统 以DBMS为核心的应用开发工具 为特定应用环境开发的数据库应用系统 3. 人员不同人员涉及不同的数据抽象级别，具有不同的数据视图 数据库管理员(DBA) 参与确定数据库中的内容和信息结构 参与存储结构和存取策略的设计 参与确定数据安全性要求和完整性约束条件 监控数据库的使用和运行 周期性转储-数据文件、日志文件 系统故障回复 介质故障回复 监视审计文件 数据库的改进和重组 性能监控和调优 定期对数据库进行重组织，以提高系统的性能 需求增加和改变时，数据库需要重构造 系统分析员、数据库设计人员 系统分析员 负责应用系统的需求分析和规范说明 与用户及数据库管理员结合确定系统的硬软件配置 参与数据库系统的概要设计 数据库设计人员 参与用户需求调查和系统分析 确定数据库中的数据 设计数据库的各级模式 应用程序员 设计和编写应用系统的程序模块 进行调试和安装 用户 通过应用系统的接口使用数据库 复杂用户直接使用数据库语言访问数据库，甚至能够基于数据库管理系统的应用程序接口编制自己的应用程序","categories":[{"name":"数据库","slug":"数据库","permalink":"http://leee9.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"study notes","slug":"study-notes","permalink":"http://leee9.cn/tags/study-notes/"}]},{"title":"Start a Blog","slug":"NEXT主题配置","date":"2021-12-19T17:53:59.000Z","updated":"2021-12-19T18:22:46.593Z","comments":true,"path":"2021/12/20/NEXT主题配置/","link":"","permalink":"http://leee9.cn/2021/12/20/NEXT%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","excerpt":"","text":"hexo开始教程 超级全的NEXT主题设置","categories":[],"tags":[{"name":"guide","slug":"guide","permalink":"http://leee9.cn/tags/guide/"}]},{"title":"装饰器 decorator","slug":"Python 装饰器decorator","date":"2021-12-17T16:00:00.000Z","updated":"2021-12-19T15:08:33.001Z","comments":true,"path":"2021/12/18/Python 装饰器decorator/","link":"","permalink":"http://leee9.cn/2021/12/18/Python%20%E8%A3%85%E9%A5%B0%E5%99%A8decorator/","excerpt":"","text":"装饰器 不改变函数代码，且保持函数调用方法不变，增加新的功能（或给类增加属性和方法） 核心思想：用一个函数（或者类）去装饰一个旧函数（或者类），造出一个新函数（或者新类） 语法规则：在原有的函数上加@符，装饰器会把下面的函数或方法当作参数传递到装饰器中 应用场景：引入日志，函数执行时间统计，执行函数前的准备工作，执行函数后的处理工作，权限校验，缓存等 123@outerdef func(): pass 1.装饰器原型与定义利用闭包，把函数当作参数传递，并且在函数内去调用传递进来的函数，并返回一个函数 12345678# 定义外函数，接收一个函数作为参数def outer(f): # 定义内函数，并且在内函数中调用了外函数的参数 def inner(): print(&quot;我是外函数中的内函数1&quot;) f() print(&quot;我是外函数中的内函数2&quot;) return inner 123456# 定义普通函数def old: print(&quot;我是普通函数&quot;)# old()直接调用 old = outer(old)# outer函数返回了inner函数old() # 此时再调用old等同于调用了inner函数 装饰器用法 12345# 改为装饰器用法@outerdef old(): print(&quot;我是一个普通函数&quot;)old() 2.统计函数执行时间12345678910111213141516inport time# 定义一个统计函数执行时间的装饰器def runtime(f): def inner(): start = time.pref_counter() f() end = time.perf_counter()-start print(f&#x27;函数执行时间为:&#123;end&#125;&#x27;) return inner@runtimedef func(): for i in range(10): print(i,end=&#x27;&#x27;) time.sleep(1)func() 3.装饰器的嵌套 普通装饰器 1234567891011def outer(f): def inner(): print(&quot;内函数1&quot;) f() print(&quot;内函数2&quot;) return inner@outerdef func(): print(&quot;普通函数&quot;)func() 再定义一个装饰器 12345678910111213141516171819202122# 装饰器1def outer(f): def inner(): print(&quot;内函数1&quot;) f() print(&quot;内函数2&quot;) return inner# 装饰器2def kuozhan(f): def kzinner(): print(&quot;扩展1&quot;) f() print(&quot;扩展2&quot;) return kzinner@kuozhan@outerdef func(): print(&quot;普通函数&quot;)func() 4.装饰带有参数的函数在inner函数中添加参数即可 1234567891011def outer(f): def inner(arg): print(&quot;内函数1&quot;) f(arg) print(&quot;内函数2&quot;) return inner@outerdef func(arg): print(f&quot;普通函数&#123;arg&#125;&quot;)func() 装饰带有多参数的函数也是一样的道理 5.带有参数的装饰器用于流程控制 给当前的装饰器套一个壳，用于接收装饰器的参数 12345678910111213141516171819def kuozhan(var) def outer(f): def inner1: print(&quot;inner1&quot;) f() def inner2(): print(&quot;inner2&quot;) f() if var == 1: return inner1 else: return inner2 return outer# 本来是outer的参数，用壳接收参数@kuozhan(1)def func(): print(&quot;普通函数&quot;)func() 6.类装饰器装饰函数12345678910111213141516class Outer(): # 魔术方法，当把该类的对象当函数调用时，自动触发 def __call__(self, f): self.f = f return self.inner # 在定义的需要返回的新方法中，进行装饰和处理 def inner(self, arg): print(&#x27;1&#x27;) self.f(arg) print(&#x27;2&#x27;) @Outer() # 实例化对象obj @obj ==&gt; obj(func) ==&gt; 执行__call__(func)方法 ==&gt; 返回inner()调用def func(arg): print(&quot;普通函数&quot;,arg)func(&#x27;a&#x27;) 7.用类方法装饰函数12345678910111213class Outer: def newinner(f): Outer.f = f # 把传递进来的函数定义为类方法 return Outer.inner # 返回一个新的类方法 def inner(): print(&#x27;1&#x27;) Outer.f() print(&#x27;2&#x27;) @Outer.newinner # Outer.newinner(func) ==&gt; Outer.innerdef func(): print(&#x27;1&#x27;)","categories":[{"name":"python","slug":"python","permalink":"http://leee9.cn/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://leee9.cn/tags/python/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"http://leee9.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"python","slug":"python","permalink":"http://leee9.cn/categories/python/"}],"tags":[{"name":"study notes","slug":"study-notes","permalink":"http://leee9.cn/tags/study-notes/"},{"name":"guide","slug":"guide","permalink":"http://leee9.cn/tags/guide/"},{"name":"python","slug":"python","permalink":"http://leee9.cn/tags/python/"}]}